from fastapi import FastAPI, Request
import httpx
from langchain.chat_models import ChatOpenAI
from langchain.prompts import PromptTemplate
from pymongo import MongoClient
import os
import json
from dotenv import load_dotenv
import re
import pandas as pd
import uuid
load_dotenv()

# ENV variables
mongo_uri = os.getenv("MONGODB_URI")
openai_api_key = os.getenv("OPENAI_API_KEY")
line_channel_token = os.getenv("LINE_CHANNEL_ACCESS_TOKEN")

# MongoDB setup
client = MongoClient(mongo_uri)
db = client.get_database("customerdb")
collection = db["customers"]

try:
    client.admin.command("ping")
    print("‚úÖ Connected to MongoDB!")
    
except Exception as e:
    print("‚ùå MongoDB connection error:", e)
    

# FastAPI app
app = FastAPI()

# ‡∏™‡∏£‡πâ‡∏≤‡∏á LLM chain
def get_llm_chain():
    prompt = PromptTemplate.from_template(
        "‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: {text} ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô JSON ‡∏ó‡∏µ‡πà‡∏°‡∏µ name, phone, email ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏∑‡πà‡∏ô‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å JSON"
    )
    llm = ChatOpenAI(
        temperature=0,
        model_name="gpt-4o-mini",  # ‡∏´‡∏£‡∏∑‡∏≠ gpt-3.5-turbo
        openai_api_key=openai_api_key
    )
    return prompt | llm


# Reply ‡πÑ‡∏õ‡∏ó‡∏µ‡πà LINE
async def reply_to_line(reply_token: str, message: str):
    headers = {
        "Authorization": f"Bearer {line_channel_token}",
        "Content-Type": "application/json"
    }
    payload = {
        "replyToken": reply_token,
        "messages": [{"type": "text", "text": message}]
    }
    async with httpx.AsyncClient() as client:
        await client.post("https://api.line.me/v2/bot/message/reply", json=payload, headers=headers)



# Webhook endpoint
@app.post("/webhook")
async def webhook(req: Request):
    body = await req.json()
    events = body.get("events", [])
    print(events)
    for event in events:
        if event["type"] == "message" and event["message"]["type"] == "text":
            text = event["message"]["text"]
            reply_token = event["replyToken"]

            # üëâ ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏°‡∏û‡πå "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤"
            if "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤" in text:
                customers = list(collection.find({}, {"_id": 0}))
                if not customers:
                    await reply_to_line(reply_token, "‚ùå ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏£‡∏±‡∏ö")
                else:
                    df = pd.DataFrame(customers)
                    filename = f"customers_{uuid.uuid4().hex}.xlsx"
                    filepath = f"/tmp/{filename}"
                    df.to_excel(filepath, index=False)

                    # URL ‡∏ö‡∏ô Render ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏´‡πâ‡πÇ‡∏´‡∏•‡∏î
                    download_url = f"https://your-app-name.onrender.com/download/{filename}"

                    await reply_to_line(reply_token, f"üì• ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà:\n{download_url}")
                    
                continue  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• LangChain


            # ‡∏™‡∏£‡πâ‡∏≤‡∏á Chain ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ
            chain = get_llm_chain()
            result = chain.invoke({"text": text})

            try:
                match = re.search(r'\{.*\}', result.content, re.DOTALL)
                data = json.loads(match.group())

                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á MongoDB
                insert_result = collection.insert_one(data)

                response_text = f"‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö: {data.get('name') or '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ä‡∏∑‡πà‡∏≠'}"
            except Exception as e:
                response_text = f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: {e}"

            await reply_to_line(reply_token, response_text)

    return {"status": "ok"}